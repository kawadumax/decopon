use crate::entities::{prelude::*, *};
use sea_orm::{ActiveValue, DatabaseConnection, DbErr, EntityTrait, InsertResult};

pub async fn insert_post(
    db: &DatabaseConnection,
    title: &str,
    text: &str,
) -> Result<InsertResult<post::ActiveModel>, DbErr> {
    let some_post = post::ActiveModel {
        title: ActiveValue::Set(title.to_owned()),
        text: ActiveValue::Set(text.to_owned()),
        ..Default::default()
    };
    let res = Post::insert(some_post).exec(db).await?;
    Ok(res)
}

pub async fn get_posts(db: &DatabaseConnection) -> Result<Vec<post::Model>, DbErr> {
    Post::find().all(db).await
}

pub async fn get_post_by_id(
    db: &DatabaseConnection,
    id: i32,
) -> Result<Option<post::Model>, DbErr> {
    Post::find_by_id(id).one(db).await
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::entities::post;
    use migration::MigratorTrait;
    use sea_orm::{Database, DatabaseBackend, MockDatabase, MockExecResult, Transaction};

    // テスト用のデータベース接続を作成するヘルパー関数
    async fn setup_test_db() -> DatabaseConnection {
        Database::connect("sqlite::memory:").await.unwrap()
        // または実際のテスト用データベースを使用
    }

    // モックデータベースを使用したテスト
    #[tokio::test]
    async fn test_insert_post_mock() {
        let db = MockDatabase::new(DatabaseBackend::Sqlite)
            .append_exec_results([MockExecResult {
                last_insert_id: 1,
                rows_affected: 1,
            }])
            .into_connection();

        let result = insert_post(&db, "Test Title", "Test Content").await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap().last_insert_id, 1);
    }

    #[tokio::test]
    async fn test_get_posts_empty() {
        let db = MockDatabase::new(DatabaseBackend::Sqlite)
            .append_query_results([Vec::<post::Model>::new()])
            .into_connection();

        let result = get_posts(&db).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap().len(), 0);
    }

    #[tokio::test]
    async fn test_get_post_by_id_found() {
        let expected_post = post::Model {
            id: 1,
            title: "Test Title".to_string(),
            text: "Test Content".to_string(),
        };

        let db = MockDatabase::new(DatabaseBackend::Sqlite)
            .append_query_results([vec![expected_post.clone()]])
            .into_connection();

        let result = get_post_by_id(&db, 1).await;

        assert!(result.is_ok());
        let post = result.unwrap();
        assert!(post.is_some());
        assert_eq!(post.unwrap().title, "Test Title");
    }

    #[tokio::test]
    async fn test_get_post_by_id_not_found() {
        let db = MockDatabase::new(DatabaseBackend::Sqlite)
            .append_query_results([Vec::<post::Model>::new()])
            .into_connection();

        let result = get_post_by_id(&db, 999).await;

        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
    }

    // 統合テスト用（実際のDBを使用）
    #[tokio::test]
    #[ignore] // 実際のDBが必要な場合は ignore を付ける
    async fn test_insert_and_get_post_integration() {
        let db = setup_test_db().await;

        // テーブル作成など必要な初期化処理
        migration::Migrator::up(&db, None).await.unwrap();

        let insert_result = insert_post(&db, "Integration Test", "Test Content").await;
        assert!(insert_result.is_ok());

        let posts = get_posts(&db).await;
        assert!(posts.is_ok());
        assert_eq!(posts.unwrap().len(), 1);
    }
}
